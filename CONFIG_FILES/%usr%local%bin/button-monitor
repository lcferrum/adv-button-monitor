#!/usr/bin/python
#n9-button-monitor v0.2
#Copyright 2012 Elliot Wolk
#####
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#####
#dependencies:
# python-qtmobility.systeminfo
# python-qtmobility.multimediakit
#####
#based on:
# Ye Olde Camerra Hack - Another fine Harmattan Hack Powered by Python(tm)!
# 2012-01-12; Thomas Perl <thp.io/about>
#

from QmSystem import QmKeys
from PySide.QtGui import QApplication, QWidget
from PySide.QtCore import QBasicTimer
from QtMobility.MultimediaKit import QCamera, QCameraExposure
from QtMobility.SystemInfo import QSystemDeviceInfo

import sys
import os
import subprocess
import re

torchAutoShutOffTime = 5*60*1000

###############
###############
###############
def getActions():
  return filter(None, [ None
  , Action([volup], cond=appOnTop("camera-ui"), action=cmd("camera-click"))
  , Action([voldn, volup, volup], cond=screenLocked, action=torch.toggle)
  , Action([volup], cond=screenLocked, action=cmd("udo klomp-cmd pause"))
  , Action([voldn], cond=screenLocked, action=cmd("udo klomp-cmd next"))
  , Action([volup, voldn], cond=screenLocked, action=cmd("udo klomp-cmd prev"))
  ])
 
def readProc(cmdarr):
  out, err = subprocess.Popen(cmdarr, stdout=subprocess.PIPE).communicate()
  return out

def screenLocked():
  return QSystemDeviceInfo().isDeviceLocked();
def screenUnlocked():
  return not screenLocked()

def appOnTop(app):
  return lambda: isAppOnTop(app)
def isAppOnTop(app):
  winId = readProc(["xprop", "-root", "_NET_ACTIVE_WINDOW"]) [40:]
  winCmd = readProc(["xprop", "-id", winId, "WM_COMMAND"]) [24:-4]
  return app in winCmd

def cmd(cmd):
  return lambda: runcmd(cmd)
def runcmd(cmd):
  print 'running cmd: "' + cmd + '"'
  subprocess.Popen(['bash', '-c', cmd])
###############
###############
###############

class TorchAutoShutOff(QWidget):
  def __init__(self, torch):
    super(TorchAutoShutOff, self).__init__()
    self.torch = torch
    self.timer = QBasicTimer()
  def schedule(self, time):
    self.timer.start(time, self)
  def cancel(self):
    self.timer.stop()
  def timerEvent(self, e):
    self.timer.stop()
    if self.torch.state == "on":
      print "auto shut-off"
      self.torch.off()

class Torch():
  def __init__(self):
    self.state = "off"

  def initCamera(self):
    self.camera = QCamera()
    self.autoShutOff = TorchAutoShutOff(self)
    self.on()
    self.autoShutOff.schedule(500)

  def toggle(self):
    if self.state == "on":
      self.off()
    else:
      self.on()

  def on(self):
    print "torch on"
    self.camera.setCaptureMode(QCamera.CaptureVideo)
    self.camera.exposure().setFlashMode(QCameraExposure.FlashTorch)
    self.camera.start()
    self.state = "on"
    self.autoShutOff.schedule(torchAutoShutOffTime)

  def off(self):
    self.autoShutOff.cancel()
    print "torch off"
    self.camera.setCaptureMode(QCamera.CaptureStillImage)
    self.camera.exposure().setFlashMode(QCameraExposure.FlashManual)
    self.camera.unlock()
    self.camera.unload()
    self.state = "off"

torch = Torch()

evtPressed = 'pressed'
evtRepeated = 'repeated'
evtReleased = 'released'

stateOn = 2
stateOff = 0

power = 20
volup = 2
voldn = 3

class Action():
  def __init__(self, pattern, action=None, cond=None):
    self.pattern = pattern
    self.action = action
    self.cond = cond

keysPressed = set()
actions = getActions()
pattern = []

def keyEvent(key, state):
  event = None
  if state == stateOn:
    if key not in keysPressed:
      event = evtPressed
    else:
      event = evtRepeated
    keysPressed.add(key)
  elif state == stateOff:
    event = evtReleased
    keysPressed.discard(key)

  if event == evtRepeated:
    return

  if event == evtPressed:
    pattern.append(key)

  if event == evtReleased and len(pattern) > 0 and pattern[0] == key:
    for action in actions:
      if action.pattern == pattern:
        if action.cond == None or action.cond():
          action.action()
    del pattern[:]


def main():
  app = QApplication(sys.argv)

  torch.initCamera()
  keys = QmKeys()
  keys.keyEvent.connect(keyEvent)
  
  app.exec_()


if __name__ == "__main__":
  sys.exit(main())

